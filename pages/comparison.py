import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import ast
from utils import safe_download_image
from plots import (
    plot_resolucao_acuracia,
    plot_timeline,
    plot_annual_coverage_multiselect,
    plot_classes_por_iniciativa,
    plot_distribuicao_classes,
    plot_distribuicao_metodologias,
    plot_acuracia_por_metodologia
)
from tools.charts import (
    create_comparison_matrix,
    create_improved_bubble_chart,
    create_ranking_chart
)
from tools.tables import gap_analysis, safe_dataframe_display

def run():
    # Carregar dados originais e preparar para filtros
    if 'df_original' not in st.session_state or 'metadata' not in st.session_state:
        from data import load_data, prepare_plot_data
        df_loaded, metadata_loaded = load_data(
            "initiative_data/initiatives_processed.csv",
            "initiative_data/metadata_processed.json"
        )
        st.session_state.df_original = df_loaded
        st.session_state.metadata = metadata_loaded
        st.session_state.df_prepared_initial = prepare_plot_data(df_loaded.copy())

    df = st.session_state.df_prepared_initial
    meta_geral = st.session_state.metadata
    df_geral_original = st.session_state.df_original

    # Filtros modernos no topo da p√°gina
    st.markdown("### üîé Filtros de Iniciativas")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        tipos = df["Tipo"].unique().tolist()
        selected_types = st.multiselect("Tipo", options=tipos, default=tipos)
    with col2:
        min_res, max_res = int(df["Resolu√ß√£o (m)"].min()), int(df["Resolu√ß√£o (m)"].max())
        selected_res = st.slider("Resolu√ß√£o (m)", min_value=min_res, max_value=max_res, value=(min_res, max_res))
    with col3:
        min_acc, max_acc = int(df["Acur√°cia (%)"].min()), int(df["Acur√°cia (%)"].max())
        selected_acc = st.slider("Acur√°cia (%)", min_value=min_acc, max_value=max_acc, value=(min_acc, max_acc))
    with col4:
        metodologias = df["Metodologia"].unique().tolist()
        selected_methods = st.multiselect("Metodologia", options=metodologias, default=metodologias)

    # Aplicar filtros
    filtered_df = df[
        (df["Tipo"].isin(selected_types)) &
        (df["Resolu√ß√£o (m)"].between(selected_res[0], selected_res[1])) &
        (df["Acur√°cia (%)"].between(selected_acc[0], selected_acc[1])) &
        (df["Metodologia"].isin(selected_methods))
    ]
    st.session_state.filtered_df = filtered_df

    if filtered_df.empty:
        st.warning("‚ö†Ô∏è Nenhuma iniciativa corresponde aos filtros selecionados. Ajuste os filtros para visualizar os dados.")
        st.stop()

    df_filt = filtered_df    # Otimiza√ß√µes de performance
    st.markdown("### ‚ö° Configura√ß√µes de Performance")
    col_perf1, col_perf2, col_perf3 = st.columns(3)
    
    with col_perf1:
        max_records = st.selectbox(
            "M√°ximo de registros:", 
            [10, 25, 50, 100, 200], 
            index=2,  # Default: 50
            help="Limitar registros melhora a performance"
        )
    
    with col_perf2:
        use_cache = st.checkbox("Cache habilitado", value=True, help="Cache acelera carregamento")
    
    with col_perf3:
        show_loading = st.checkbox("Indicadores de carregamento", value=True)    # Aplicar limita√ß√£o de dados para performance
    if len(df_filt) > max_records:
        df_filt_limited = df_filt.nlargest(max_records, 'Acur√°cia (%)')
        st.warning(f"‚ö†Ô∏è Mostrando top {max_records} iniciativas (de {len(df_filt)} total) para melhor performance")
    else:
        df_filt_limited = df_filt.copy()

    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìä Barras Duplas",
        "üéØ Resolu√ß√£o vs Acur√°cia",
        "üìÖ Cobertura Temporal",
        "üè∑Ô∏è N√∫mero de Classes",
        "‚öôÔ∏è Metodologias"
    ])

    with tab1:
        st.subheader("Barras Duplas: Acur√°cia x Resolu√ß√£o")
        df_filt_limited['resolucao_norm'] = (1 / df_filt_limited['Resolu√ß√£o (m)']) / (1 / df_filt_limited['Resolu√ß√£o (m)']).max()
        fig = go.Figure()
        fig.add_trace(go.Bar(
            y=df_filt_limited['Nome'],
            x=df_filt_limited['Acur√°cia (%)'],
            name='Acur√°cia (%)',
            orientation='h',
            marker_color='royalblue'
        ))
        fig.add_trace(go.Bar(
            y=df_filt_limited['Nome'],
            x=df_filt_limited['resolucao_norm'] * 100,  # Converter para porcentagem
            name='Resolu√ß√£o (normalizada)',
            orientation='h',
            marker_color='orange'
        ))
        fig.update_layout(
            barmode='group',
            xaxis_title='Valor (%)',
            yaxis_title='Produto',
            title='Compara√ß√£o: Acur√°cia vs Resolu√ß√£o',
            height=max(400, len(df_filt_limited) * 25)
        )
        st.plotly_chart(fig, use_container_width=True)
        safe_download_image(fig, "barras_duplas_comparativo.png", "‚¨áÔ∏è Baixar Gr√°fico")

    with tab2:
        st.subheader("Resolu√ß√£o Espacial vs Acur√°cia (Scatter)")
        # Scatterplot moderno
        fig_scatter = px.scatter(
            df_filt_limited,
            x='Resolu√ß√£o (m)',
            y='Acur√°cia (%)',
            color='Metodologia' if 'Metodologia' in df_filt_limited.columns else None,
            hover_name='Nome',
            size='Classes' if 'Classes' in df_filt_limited.columns else None,
            title="Acur√°cia vs Resolu√ß√£o Espacial",
            labels={
                'Resolu√ß√£o (m)': 'Resolu√ß√£o Espacial (m)',
                'Acur√°cia (%)': 'Acur√°cia (%)',
                'Metodologia': 'Metodologia',
                'Classes': 'N¬∫ de Classes'
            },
            height=500
        )
        fig_scatter.update_traces(marker=dict(size=14, opacity=0.8, line=dict(width=2, color='white')))
        st.plotly_chart(fig_scatter, use_container_width=True)
        safe_download_image(fig_scatter, "scatter_resolucao_acuracia.png", "‚¨áÔ∏è Baixar Scatter (PNG)")

        st.subheader("Disponibilidade Temporal das Iniciativas")
        from plots import plot_ano_overlap
        fig_disp = plot_ano_overlap(meta_geral, df_filt_limited)
        st.plotly_chart(fig_disp, use_container_width=True)
        safe_download_image(fig_disp, "disponibilidade_temporal.png", "‚¨áÔ∏è Baixar Disponibilidade (PNG)")

    with tab3:
        st.markdown('<div class="timeline-container"><h2 class="timeline-title">üìÖ Linha do Tempo Geral das Iniciativas</h2></div>', unsafe_allow_html=True)
        fig_timeline = plot_timeline(meta_geral, df_geral_original) 
        st.plotly_chart(fig_timeline, use_container_width=True)
        safe_download_image(fig_timeline, "timeline_geral.png", "‚¨áÔ∏è Baixar Timeline (PNG)")
        
        gap_df = gap_analysis(meta_geral, df_geral_original)
        if not gap_df.empty:
            st.markdown('#### Lacunas Temporais nas S√©ries (Todas Iniciativas)')
            # Tabela interativa com ordena√ß√£o e sem √≠ndice
            st.dataframe(
                gap_df.sort_values('Maior lacuna temporal', ascending=False),
                use_container_width=True,
                hide_index=True,
                column_config={
                    "Nome": st.column_config.TextColumn("Nome", width="large"),
                    "Primeiro Ano": st.column_config.NumberColumn("Primeiro ano de cobertura", format="%d"),
                    "√öltimo Ano": st.column_config.NumberColumn("√öltimo ano de cobertura", format="%d"),
                    "N√∫mero de anos com lacuna temporal": st.column_config.NumberColumn("N√∫mero de anos com lacuna temporal", format="%d"),
                    "Maior lacuna temporal": st.column_config.NumberColumn("Maior lacuna temporal", format="%d"),
                    "Tipo": st.column_config.TextColumn("Tipo", width="medium")
                }
            )
            # Bot√£o para download da tabela de lacunas temporais
            st.download_button(
                "‚¨áÔ∏è Baixar Tabela de Lacunas Temporais (CSV)",
                data=gap_df.sort_values('Maior lacuna temporal', ascending=False).to_csv(index=False).encode('utf-8'),
                file_name="lacunas_temporais_iniciativas.csv",
                mime="text/csv",
                help="Baixa a tabela completa de lacunas temporais das iniciativas"
            )
        else:
            st.info('Todas as iniciativas possuem s√©ries temporais cont√≠nuas ou apenas um ano dispon√≠vel.')

    with tab4:
        st.subheader("Distribui√ß√£o do N√∫mero de Classes")
        col1_tab3, col2_tab3 = st.columns(2)
        with col1_tab3:
            fig_bar_classes = plot_classes_por_iniciativa(df_filt)
            st.plotly_chart(fig_bar_classes, use_container_width=True)
            safe_download_image(fig_bar_classes, "classes_por_iniciativa.png", "‚¨áÔ∏è Baixar Gr√°fico Barras (PNG)")
        with col2_tab3:
            fig_hist_classes = plot_distribuicao_classes(df_filt)
            st.plotly_chart(fig_hist_classes, use_container_width=True)
            safe_download_image(fig_hist_classes, "distribuicao_classes.png", "‚¨áÔ∏è Baixar Histograma (PNG)")

    with tab5:
        st.subheader("Distribui√ß√£o por Metodologias")
        col1_tab4, col2_tab4 = st.columns(2)
        with col1_tab4:
            method_counts = df_filt['Metodologia'].value_counts()
            fig_metodologias = plot_distribuicao_metodologias(method_counts)
            st.plotly_chart(fig_metodologias, use_container_width=True)
            safe_download_image(fig_metodologias, "distribuicao_metodologias.png", "‚¨áÔ∏è Baixar Gr√°fico Metodologias (PNG)")
        
        with col2_tab4:
            st.markdown("#### Acur√°cia por Metodologia")
            fig_acuracia_metodologia = plot_acuracia_por_metodologia(df_filt)
            st.plotly_chart(fig_acuracia_metodologia, use_container_width=True)
            safe_download_image(fig_acuracia_metodologia, "acuracia_por_metodologia.png", "‚¨áÔ∏è Baixar Acur√°cia Metodologia (PNG)")

    # Se√ß√£o de Performance e Estat√≠sticas
    st.markdown("---")
    st.markdown("### üìä Estat√≠sticas de Performance")
    
    col_stats1, col_stats2, col_stats3, col_stats4 = st.columns(4)
    
    with col_stats1:
        total_records = len(df_geral_original)
        filtered_records = len(df_filt)
        st.metric("Total de Iniciativas", total_records, delta=None)
    
    with col_stats2:
        displayed_records = len(df_filt_limited)
        st.metric("Registros Exibidos", displayed_records, delta=f"-{filtered_records - displayed_records}" if filtered_records > displayed_records else None)
    
    with col_stats3:
        cache_info = "‚úÖ Ativo" if use_cache else "‚ùå Desabilitado"
        st.metric("Cache", cache_info, delta=None)
    
    with col_stats4:
        perf_mode = f"M√°x {max_records}"
        st.metric("Limite Performance", perf_mode, delta=None)

    st.info(f"""
        **üìà An√°lise atual:**
        - **Produtos analisados:** {len(df_filt_limited)} iniciativas (filtradas)
        - **M√©tricas avaliadas:** Acur√°cia, Resolu√ß√£o, Classes, Metodologia, Escopo
        - **Performance:** Dados limitados a {max_records} registros para otimiza√ß√£o
        
        **üí° Funcionalidades:**
        - Filtros interativos por tipo, resolu√ß√£o, acur√°cia e metodologia
        - Normaliza√ß√£o autom√°tica de dados para compara√ß√£o
        - Tratamento robusto de dados ausentes
        - Downloads dispon√≠veis para todos os gr√°ficos principais
        - Cache inteligente para melhor performance
        
        **üß™ Testes de visualiza√ß√µes:** Movidos para sistema separado em `/tests/teste_graficos.py`
        """)
    
    # Dicas de performance
    with st.expander("üí° Dicas para Melhor Performance"):
        st.markdown("""
        **Para melhorar a velocidade do dashboard:**
        
        1. **Reduzir dados:** Use filtros para reduzir o n√∫mero de iniciativas analisadas
        2. **Limite de registros:** Configure um limite menor (10-25) para visualiza√ß√µes complexas
        3. **Cache:** Mantenha o cache habilitado para evitar rec√°lculos
        4. **Visualiza√ß√£o simples:** Use "Coordenadas Paralelas" para an√°lises r√°pidas
        5. **Fechar abas:** Feche abas n√£o utilizadas para liberar mem√≥ria
        
        **Visualiza√ß√µes por complexidade:**
        - üìä **Coordenadas Paralelas**: Mais r√°pido (at√© 100+ registros)
        - üéØ **Radar**: M√©dio (m√°ximo 15 registros)
        - üìã **Matriz**: Complexo (at√© 10 registros)
        """)
        
    # Bot√£o para limpar cache
    if st.button("üßπ Limpar Cache", help="Limpa o cache para for√ßar atualiza√ß√£o dos dados"):
        st.cache_data.clear()
        st.success("Cache limpo com sucesso! A pr√≥xima visualiza√ß√£o ser√° regenerada.")
